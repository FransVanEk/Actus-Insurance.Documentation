# Contracts Module

This document explains what a contract is in this system, how it is structured, and how it moves through its lifecycle.

See also: [Domain Model](../domain-model.md) | [Calculation Engine](./calculation-engine.md)

---

## Business View

### What a Contract Is

A **contract** in this system represents a financial agreement — most commonly a loan or bond. The contract specifies:

- The amount of money involved (notional principal)
- The interest rate and how it may change over time
- When payments are due
- When the principal is repaid

The system currently implements the **PAM** (Principal At Maturity) contract type from the ACTUS standard. PAM contracts pay interest periodically and return the full principal at the end.

### Why Contracts Are Modelled This Way

The ACTUS standard defines a precise, machine-readable format for every contract type. This makes calculations auditable and consistent — the same input always produces the same output regardless of the system performing the calculation.

### Contract Lifecycle

1. **Definition** — A `PamContractTerms` object is created with all contract terms.
2. **Conversion** — The terms are converted into a GPU-compatible struct (`PamContractGpu`) with a pre-computed event schedule.
3. **Execution** — The GPU kernel processes each event in sequence, computing payoffs and updating state.
4. **Results** — Each event produces a `PamEventResultGpu` record with the payoff and updated state variables.

### Risks If Contracts Fail

- Incorrect payoff calculations lead to incorrect financial reports.
- Missing events (e.g., skipped interest payments) cause understatement of liabilities.
- Incorrect initial state initialisation causes wrong accrued interest from the first event.

---

## Technical View

### Contract Definition

Contracts are originally defined as `PamContractTerms` objects (from the `ActusInsurance.Core.CPU` package). The GPU library does not define its own high-level contract type — it consumes the CPU domain model.

Key fields of `PamContractTerms` used by the adapter:

| Field | GPU Field | Description |
|---|---|---|
| `InitialExchangeDate` | `InitialExchangeDateTicks` | When principal is first exchanged |
| `StatusDate` | `StatusDateTicks` | The "as-of" date for initial state |
| `MaturityDate` | `MaturityDateTicks` | When the contract ends |
| `NotionalPrincipal` | `NotionalPrincipal` | Face value |
| `NominalInterestRate` | `NominalInterestRate` | Starting interest rate |
| `DayCountConvention` | `DayCountConventionCode` | Accrual convention |
| `RoleSign` | `RoleSign` | +1 = lender, −1 = borrower |
| `FeeBasis` | `FeeBasisN` | Fee calculation basis (`"N"` = notional, else absolute) |
| `MarketObjectCodeOfRateReset` | (used to look up rate index) | Identifies the market rate to use at RR events |

Source: `src/ActusInsurance.GPU/PamV3Adapter.cs`

### Contract Structure on GPU

Each `PamContractGpu` struct contains:

1. **Contract terms** — immutable values from `PamContractTerms` (dates, rates, principal).
2. **Initial state** — mutable state at `StatusDate`, pre-computed before upload. This is the starting point for the kernel's state machine.
3. **Event slice** — `EventOffset` and `EventCount` index into the shared flat `PamEventGpu[]` array.
4. **Rate slice** — `MarketRateOffset` and `MarketRateCount` index into the shared flat `GpuMarketRate[]` array.

This flat array layout avoids pointer indirection on the GPU, which would require managed memory.

### Event Schedule Generation

The event schedule is generated by `PrincipalAtMaturity.Schedule()` from `ActusInsurance.Core.CPU`. The adapter iterates the schedule and packs each event into a `PamEventGpu`:

```csharp
allEvents.Add(new PamEventGpu
{
    ScheduleTimeTicks = ev.ScheduleTime.Ticks,
    EventTimeTicks    = ev.Time.Ticks,
    CalcTimeTicks     = adjuster.ShiftCalcTime(ev.ScheduleTime).Ticks,
    EventType         = ConvertEventType(ev.Type),
    RateIndex         = rateIndex,   // -1 if no rate lookup needed
});
```

Source: `src/ActusInsurance.GPU/PamV3Adapter.cs` lines 123–160

### Initial State Initialisation

Before the kernel can run, each contract's initial state must be computed from the `StatusDate`:

- If `InitialExchangeDate > StatusDate`, the contract has not yet started: `notionalPrincipal = 0`, `nominalInterestRate = 0`.
- Otherwise: `notionalPrincipal = RoleSign * NotionalPrincipal`.
- `accruedInterest` is computed from the last interest payment date before `StatusDate` using the interest payment schedule, unless `AccruedInterest` is explicitly set.
- `feeAccrued` defaults to the explicit `FeeAccrued` value or zero.

Source: `src/ActusInsurance.GPU/PamV3Adapter.cs` — `InitialiseState()` method

### Business Day Adjustment

Calc times are adjusted using a `BusinessDayAdjuster` based on the contract's `BusinessDayConvention` and `Calendar`:

| Calendar | Behaviour |
|---|---|
| `MF` | Monday–Friday (no holiday list) |
| `MFH` | Monday–Friday with holidays |
| `NC` | No adjustment |

Source: `src/ActusInsurance.GPU/PamV3Adapter.cs` — `CreateBusinessDayAdjuster()`

### Kernel Execution (State Machine)

For each event the kernel:

1. **Computes year fraction** (if accrual is needed for this event type).
2. **Looks up market rate** (if `RateIndex >= 0`).
3. **Computes payoff** (based on event type and current state).
4. **Updates accrued interest and fee** (if this event type triggers accrual).
5. **Applies state transition** (e.g., after IP, `accruedInterest = 0`).
6. **Writes result** to the output array.

Event types that trigger accrual: `IP`, `IPCI`, `RR`, `RRF`, `FP`, `SC`.

Source: `src/ActusInsurance.GPU/PamGpuKernel.cs` — `NeedsAccrual()`

### Contract Lifecycle Diagram

```
flowchart TD
    A[PamContractTerms]
    B[PamV3Adapter.Convert]
    C[PamContractGpu plus events plus rates]
    D[Upload to GPU]
    E[PamGpuKernel per thread]
    F[PamEventResultGpu per event]
    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
```

### Event Type Payoff Logic

| Event | Payoff Formula |
|---|---|
| IED | `roleSign * -1 * (notionalPrincipal + premiumDiscountAtIED)` |
| MD | `notionalScalingMultiplier * notionalPrincipal` |
| PRD | `roleSign * -1 * priceAtPurchaseDate` |
| TD | `roleSign * priceAtTerminationDate` |
| IP | `interestScalingMultiplier * (accruedInterest + yf * nominalInterestRate * notionalPrincipal)` |
| IPCI | `0` (capitalises interest into principal) |
| RR / RRF | `0` (updates rate only) |
| FP | If `feeBasisN=0`: `roleSign * feeRate`; else: `feeAccrued + notionalPrincipal * feeRate * yf` |
| SC | `0` (updates scaling multipliers) |

Source: `src/ActusInsurance.GPU/PamGpuKernel.cs` lines 54–102

### Evidence from Code

- `src/ActusInsurance.GPU/PamV3Adapter.cs`
- `src/ActusInsurance.GPU/PamGpuKernel.cs`
- `src/ActusInsurance.GPU/Models/PamContractGpu.cs`
- `src/ActusInsurance.GPU/Models/PamEventGpu.cs`
- `src/ActusInsurance.GPU/Models/PamEventResultGpu.cs`
- `src/ActusInsurance.GPU/Models/GpuEventType.cs`
